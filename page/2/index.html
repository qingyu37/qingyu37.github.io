<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="晴雨之中，唯得一小屋以安。">
<meta property="og:type" content="website">
<meta property="og:title" content="晴雨屋">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="晴雨屋">
<meta property="og:description" content="晴雨之中，唯得一小屋以安。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="晴雨">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>晴雨屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">晴雨屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/03/spring/springMVC/SpringMVC%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴雨">
      <meta itemprop="description" content="晴雨之中，唯得一小屋以安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="晴雨屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/03/spring/springMVC/SpringMVC%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">SpringMVC组件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-07-03 20:14:45 / 修改时间：21:28:42" itemprop="dateCreated datePublished" datetime="2023-07-03T20:14:45+08:00">2023-07-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Spring的执行流程"><a href="#1-Spring的执行流程" class="headerlink" title="1. Spring的执行流程"></a>1. Spring的执行流程</h2><ol>
<li>用户发送请求至前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandleMapping处理器映射器</li>
<li>处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找），生成处理器对象及处理器拦截器（如果有），一并返回给DispatcherServlet</li>
<li>DispatcherServlet调用HandleAdapter处理器适配器</li>
<li>HandleAdapter经过适配调用具体的处理器（Controller，也叫后端控制器）</li>
<li>Controller执行完成返回ModelAndView</li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>
<li>ViewReslover解析后返回具体View</li>
<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中），DispatcherServlet响应用户</li>
</ol>
<h2 id="2-SpringMVC注解解析"><a href="#2-SpringMVC注解解析" class="headerlink" title="2. SpringMVC注解解析"></a>2. SpringMVC注解解析</h2><p><strong>@RequsetMapping</strong></p>
<ul>
<li>作用：用于建立请求URL和处理请求方法之间的对应关系</li>
<li>位置：<ul>
<li>类上，请求URL的第一级访问目录。此处不写的话，就相当于应用的根目录</li>
<li>方法上，请求URL的第二级访问目录，与类上的使用@RequestMapping标注的一级目录一起组成访问虚拟路径属性</li>
<li>value：用于指定请求的URL，它和path属性的作用一样</li>
<li>method：用于指定请求的方式</li>
<li>params：用于指定限制请求参数的条件，它支持简单的表达式，要求请求参数的key和value必须和配置的一模一样，例如：<ul>
<li>params：{“accountName”}，表示请求参数必须有accountName</li>
<li>params：{“moeny!100”}，表示请求参数中money不能是100</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>mvc命名空间引入<ul>
<li>命名空间：xmlns:context&#x3D;”<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a>“ xmlns:mvc&#x3D;”<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/mvc">http://www.springframework.org/schema/mvc</a>“ </li>
<li>约束地址：”<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a>“ “<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a>“ “<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/mvc">http://www.springframework.org/schema/mvc</a>“ “<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/mvc/spring-mvc.xsd">http://www.springframework.org/schema/mvc/spring-mvc.xsd</a>“</li>
</ul>
</li>
<li>组件扫描<br>SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;context:component-scan base-package&#x3D;”com.xxx.controller”&#x2F;&gt;进行组件扫描</li>
</ol>
<h2 id="3-SpringMVC的XML配置解析"><a href="#3-SpringMVC的XML配置解析" class="headerlink" title="3. SpringMVC的XML配置解析"></a>3. SpringMVC的XML配置解析</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/02/spring/springMVC/SpringMVC%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴雨">
      <meta itemprop="description" content="晴雨之中，唯得一小屋以安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="晴雨屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/02/spring/springMVC/SpringMVC%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">SpringMVC简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-07-02 12:13:45 / 修改时间：19:28:21" itemprop="dateCreated datePublished" datetime="2023-07-02T12:13:45+08:00">2023-07-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow中</p>
<p>SpringMVC已成为目前最主流的MVC框架之一。它通过一套框架，让一个简单的Java类称为处理请求的控制器，而不用实现接口。同时也支持RESTful风格编程</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/01/spring/springMVC/Spring%E9%9B%86%E6%88%90Web%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴雨">
      <meta itemprop="description" content="晴雨之中，唯得一小屋以安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="晴雨屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/01/spring/springMVC/Spring%E9%9B%86%E6%88%90Web%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">Spring集成Web环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-01 21:05:16" itemprop="dateCreated datePublished" datetime="2023-07-01T21:05:16+08:00">2023-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-02 11:35:39" itemprop="dateModified" datetime="2023-07-02T11:35:39+08:00">2023-07-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-ApplicationContext应用上下文获取方式"><a href="#1-ApplicationContext应用上下文获取方式" class="headerlink" title="1. ApplicationContext应用上下文获取方式"></a>1. ApplicationContext应用上下文获取方式</h2><p>应用上下文对象是通过new ClassPathXmlApplicationContext(spring配置文件)方式获取的，但是每次从容器中获得Bean时都要编写new ClassPathXmlApplicationContext(spring配置文件)，这样的弊端是配置文件加载多次，应用上下文对象创建多次</p>
<p>在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，再将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获取应用上下文ApplicationContext对象了。</p>
<h2 id="2-Spring提供获取应用上下文的工具"><a href="#2-Spring提供获取应用上下文的工具" class="headerlink" title="2. Spring提供获取应用上下文的工具"></a>2. Spring提供获取应用上下文的工具</h2><p>Spring提供了一个监听器ContextLoaderListener就是对监听功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具Web ApplicationContextUtils供使用者获得应用上下文对象</p>
<ol>
<li>在web.xml中配置ContextLoaderListener监听器(导入spring-web坐标)</li>
<li>使用Web ApplicationContextUtils获得应用上下文对象ApplicationContext</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/01/spring/Spring/Spring%E6%95%B4%E5%90%88Junit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴雨">
      <meta itemprop="description" content="晴雨之中，唯得一小屋以安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="晴雨屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/01/spring/Spring/Spring%E6%95%B4%E5%90%88Junit/" class="post-title-link" itemprop="url">Spring整合Junit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-07-01 20:44:16 / 修改时间：20:50:53" itemprop="dateCreated datePublished" datetime="2023-07-01T20:44:16+08:00">2023-07-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-原始Junit测试Spring的问题"><a href="#1-原始Junit测试Spring的问题" class="headerlink" title="1. 原始Junit测试Spring的问题"></a>1. 原始Junit测试Spring的问题</h2><p>在测试类中，每个测试方法都有以下两行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app = new        AnnotationConfigApplicationContext(SpringConfiguration.class);  </span><br><span class="line">UserService userService = app.getBean(UserService.class);</span><br></pre></td></tr></table></figure>
<p>它的作用是获取容器，如果不写的话， 会提示空指针异常</p>
<h2 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2. 解决思路"></a>2. 解决思路</h2><ul>
<li>让SpringJuint负责创建Spring容器，但需要将配置文件的名称告诉它</li>
<li>将需要进行测试的Bean直接在测试类中进行注入</li>
</ul>
<h2 id="3-Spring集成Junit步骤"><a href="#3-Spring集成Junit步骤" class="headerlink" title="3. Spring集成Junit步骤"></a>3. Spring集成Junit步骤</h2><ol>
<li>导入Spring集成Junit的坐标</li>
<li>使用@Runwith注解替换原来的运行期</li>
<li>使用@ContextConfiguration指定配置文件或配置类</li>
<li>使用@Autowired注入需要测试的对象</li>
<li>创建测试方法进行测试</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/30/spring/Spring/Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴雨">
      <meta itemprop="description" content="晴雨之中，唯得一小屋以安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="晴雨屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/30/spring/Spring/Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">Spring注解开发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-30 23:40:23" itemprop="dateCreated datePublished" datetime="2023-06-30T23:40:23+08:00">2023-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-01 20:43:48" itemprop="dateModified" datetime="2023-07-01T20:43:48+08:00">2023-07-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Spring原始注解"><a href="#1-Spring原始注解" class="headerlink" title="1. Spring原始注解"></a>1. Spring原始注解</h2><p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率， 所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率<br>Spring原始注解主要是替代&lt;Bean&gt;的配置</p>
<table>
<thead>
<tr>
<th align="center">注解</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@Component</td>
<td align="center">使用在类上用于实例化Bean</td>
</tr>
<tr>
<td align="center">@Controller</td>
<td align="center">使用在web层类上用于实例化Bean</td>
</tr>
<tr>
<td align="center">@Service</td>
<td align="center">使用在service层类上用于实例化Bean</td>
</tr>
<tr>
<td align="center">@Repository</td>
<td align="center">使用在dao层类上用于实例化Bean</td>
</tr>
<tr>
<td align="center">@Autowired</td>
<td align="center">使用在字段上用于根据类型依赖注入</td>
</tr>
<tr>
<td align="center">@Qualifier</td>
<td align="center">结合@Autowired一起使用用于根据名称进行依赖注入</td>
</tr>
<tr>
<td align="center">@Resource</td>
<td align="center">相当于@Autowired+@Qualifier，按照名称进行注入</td>
</tr>
<tr>
<td align="center">@Value</td>
<td align="center">注入普通属性</td>
</tr>
<tr>
<td align="center">@Scope</td>
<td align="center">标注Bean的作用范围</td>
</tr>
<tr>
<td align="center">@PostConstruce</td>
<td align="center">使用在方法上标注该方法是Bean的初始化方法</td>
</tr>
<tr>
<td align="center">@PreDestroy</td>
<td align="center">使用在方法上标注该方法是Bean的销毁方法</td>
</tr>
</tbody></table>
<p><em>使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别注解配置的类、字段和方法</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;com.xjy&quot;&gt;&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-Spring新注解"><a href="#2-Spring新注解" class="headerlink" title="2. Spring新注解"></a>2. Spring新注解</h2><p>使用上面的注解不能全部替代xml配置文件，还需要使用注解替代的配置如下：</p>
<ul>
<li>非自定义的Bean的配置：&lt;bean&gt;</li>
<li>加载properties文件的配置：&lt;context:property-placeholder&gt;</li>
<li>组件扫描的配置：&lt;context:component-scan&gt;</li>
<li>引入其他文件：&lt;import&gt;</li>
</ul>
<table>
<thead>
<tr>
<th align="center">注解</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@Configuration</td>
<td align="center">用于指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td align="center">@ComponentScan</td>
<td align="center">用于指定Spring在初始化容器时要扫描的包，作用和在Spring的xml配置文件中的&lt;context:component-scan base-package&#x3D;”com.xjy”&#x2F;&gt;一样</td>
</tr>
<tr>
<td align="center">@Bean</td>
<td align="center">使用在方法上，标注将该方法的返回值存储到Spring容器中</td>
</tr>
<tr>
<td align="center">@PropertySource</td>
<td align="center">用于加载.properties文件中的配置</td>
</tr>
<tr>
<td align="center">@Import</td>
<td align="center">用于导入其他配置类</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/30/spring/Spring/Spring%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴雨">
      <meta itemprop="description" content="晴雨之中，唯得一小屋以安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="晴雨屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/30/spring/Spring/Spring%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90/" class="post-title-link" itemprop="url">Spring相关API</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-30 21:15:20" itemprop="dateCreated datePublished" datetime="2023-06-30T21:15:20+08:00">2023-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-01 20:43:47" itemprop="dateModified" datetime="2023-07-01T20:43:47+08:00">2023-07-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-数据源（连接池）的作用"><a href="#1-数据源（连接池）的作用" class="headerlink" title="1. 数据源（连接池）的作用"></a>1. 数据源（连接池）的作用</h2><ul>
<li><p>数据源是为了提高程序性能而出现的</p>
</li>
<li><p>事先实例化数据源，初始化部分连接资源</p>
</li>
<li><p>使用连接资源时从数据源中获取</p>
</li>
<li><p>使用完毕后将连接资源归还给数据源</p>
<pre><code>  常见数据源：DBCP、C3P0、BoneCP、Druid等
</code></pre>
</li>
</ul>
<h2 id="2-数据源的开发步骤"><a href="#2-数据源的开发步骤" class="headerlink" title="2. 数据源的开发步骤"></a>2. 数据源的开发步骤</h2><ol>
<li>导入数据源的坐标和数据库驱动坐标</li>
<li>创建数据源对象</li>
<li>设置数据源的基本连接数据</li>
<li>使用数据源获取连接资源和归还连接资源</li>
</ol>
<h2 id="3-Spring配置数据源"><a href="#3-Spring配置数据源" class="headerlink" title="3. Spring配置数据源"></a>3. Spring配置数据源</h2><p>可以将DataSource的创建权交由Spring来完成</p>
<h2 id="4-抽取jdbc配置文件"><a href="#4-抽取jdbc配置文件" class="headerlink" title="4. 抽取jdbc配置文件"></a>4. 抽取jdbc配置文件</h2><p>applicationContext.xml加载jdbc.propertites配置文件获得连接信息。</p>
<p>首先，引入context命名空间和约束路径：</p>
<ul>
<li>命名空间：<em>xmlns:context&#x3D;”<a target="_blank" rel="noopener" href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a>“</em></li>
<li>约束路径：<em><a target="_blank" rel="noopener" href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a></em><br>  <em><a target="_blank" rel="noopener" href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a></em></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;  </span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;  </span><br><span class="line">&lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;  </span><br><span class="line">&lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;  </span><br><span class="line">&lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;  </span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>Spring容器加载properties文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=&quot;xx.properties&quot;/&gt;</span><br><span class="line">&lt;property name=&quot;xx&quot; value=&quot;$&#123;key&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/30/spring/Spring/Spring%E7%9B%B8%E5%85%B3API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴雨">
      <meta itemprop="description" content="晴雨之中，唯得一小屋以安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="晴雨屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/30/spring/Spring/Spring%E7%9B%B8%E5%85%B3API/" class="post-title-link" itemprop="url">Spring相关API</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-30 20:12:13 / 修改时间：21:14:12" itemprop="dateCreated datePublished" datetime="2023-06-30T20:12:13+08:00">2023-06-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-ApplicationContext的继承体系"><a href="#1-ApplicationContext的继承体系" class="headerlink" title="1. ApplicationContext的继承体系"></a>1. ApplicationContext的继承体系</h2><p>applicationContext：接口类型，代表应用上下文，可以通过其实例获得Spring容器中的Bean对象<br><img src="https://s2.loli.net/2023/06/30/YXL3lfmrxIu5Ws8.png" alt="20191226154557828.png"></p>
<h2 id="2-ApplicationContext的实现类"><a href="#2-ApplicationContext的实现类" class="headerlink" title="2. ApplicationContext的实现类"></a>2. ApplicationContext的实现类</h2><ol>
<li>ClassPathXmlApplicationContext<ul>
<li>从类的根路径下加载配置文件推荐用这种</li>
</ul>
</li>
<li>FileSystemXmlApplicationContext<ul>
<li>从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置</li>
</ul>
</li>
<li>AnnotationConfigApplicationContext<ul>
<li>当使用注解配置容器对象时，需要使用此类来创建spring容器，用它来读取注解</li>
</ul>
</li>
</ol>
<h2 id="3-getBean-方法使用"><a href="#3-getBean-方法使用" class="headerlink" title="3. getBean()方法使用"></a>3. getBean()方法使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">	<span class="built_in">this</span>.assertBeanFactoryActive();  </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.getBeanFactory().getBean(name);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">	<span class="built_in">this</span>.assertBeanFactoryActive();  </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.getBeanFactory().getBean(name, requiredType);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>Spring的重点API</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app = new ClasspathXmlApplicationContext(&quot;xml文件&quot;)</span><br><span class="line">app.getBean(&quot;id&quot;)</span><br><span class="line">app.getBean(&quot;Class&quot;)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/30/spring/Spring/Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴雨">
      <meta itemprop="description" content="晴雨之中，唯得一小屋以安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="晴雨屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/30/spring/Spring/Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">Spring配置文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-30 16:40:55" itemprop="dateCreated datePublished" datetime="2023-06-30T16:40:55+08:00">2023-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-01 20:43:46" itemprop="dateModified" datetime="2023-07-01T20:43:46+08:00">2023-07-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Bean标签基本配置"><a href="#1-Bean标签基本配置" class="headerlink" title="1. Bean标签基本配置"></a>1. Bean标签基本配置</h2><p>默认情况下调用类中的无参构造，如果没有无参构造就会构建失败</p>
<p>基本属性：</p>
<ul>
<li><strong>id</strong> Bean实例在Spring容器中的唯一标识</li>
<li><strong>class</strong> Bean的全限定名称</li>
</ul>
<h2 id="2-Bean标签范围配置"><a href="#2-Bean标签范围配置" class="headerlink" title="2. Bean标签范围配置"></a>2. Bean标签范围配置</h2><p>scope：对象的作用范围，取值如下</p>
<table>
<thead>
<tr>
<th align="center">取值范围</th>
<th align="center">单例的</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>singleton</strong></td>
<td align="center">默认值，单例的</td>
</tr>
<tr>
<td align="center"><strong>prototype</strong></td>
<td align="center">多例的</td>
</tr>
<tr>
<td align="center">request</td>
<td align="center">web项目中，Spring创建一个Bean的对象，将对象存入到request域中</td>
</tr>
<tr>
<td align="center">session</td>
<td align="center">web项目中，Spring创建一个Bean的对象，将对象存入到session域中</td>
</tr>
<tr>
<td align="center">global session</td>
<td align="center">WEB项目中，应用在Portlet环境，如果没有Portlet环境，则相当于session</td>
</tr>
</tbody></table>
<p>（1） singleton时</p>
<ul>
<li>Bean的实例化个数：1个</li>
<li>Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例</li>
<li>Bean的生命周期：<ul>
<li>对象创建：当应用加载，创建容器时，对象就被创建了</li>
<li>对象运行：只要容器在，对象一直活着</li>
<li>对象销毁：当应用卸载，销毁容器时，对象就被销毁了</li>
</ul>
</li>
</ul>
<p>（2） prototype时</p>
<ul>
<li>Bean的实例化个数：多个</li>
<li>Bean的实例化时机：当调用getBean()方法时实例Bean</li>
<li>Bean的生命周期：<ul>
<li>对象创建：当调用对象时，创建新的对象实例</li>
<li>对象运行：只要对象在使用中，就一直活着</li>
<li>对象销毁：当对象长时间不用时，被java的gc回收了</li>
</ul>
</li>
</ul>
<h2 id="3-Bean生命周期配置"><a href="#3-Bean生命周期配置" class="headerlink" title="3. Bean生命周期配置"></a>3. Bean生命周期配置</h2><ul>
<li><strong>init-method</strong> 指定类中的初始化方法名称</li>
<li><strong>destroy-method</strong> 指定类中销毁方法名称</li>
</ul>
<h2 id="4-Bean实例化三种方法"><a href="#4-Bean实例化三种方法" class="headerlink" title="4. Bean实例化三种方法"></a>4. Bean实例化三种方法</h2><ul>
<li>无参构造方法实例化</li>
<li>工厂静态方法实例化</li>
<li>工厂实例方法实例化</li>
</ul>
<h2 id="5-Bean的依赖注入分析"><a href="#5-Bean的依赖注入分析" class="headerlink" title="5. Bean的依赖注入分析"></a>5. Bean的依赖注入分析</h2><p>因为UserService和UserDao都在Spring容器中，而最终程序使用的是UserService，所以可以在Spring容器中将UserDao设置在UserService内部</p>
<h2 id="6-Bean的依赖注入概念"><a href="#6-Bean的依赖注入概念" class="headerlink" title="6. Bean的依赖注入概念"></a>6. Bean的依赖注入概念</h2><p><strong>依赖注入</strong> <em>(Dependency Injection)</em> Spring框架核心IOC的具体实现</p>
<p>在编写程序时，通过控制反转，将对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。IOC解耦只是降低了它们的依赖关系，而不会消除。例如，业务层依然会调用持久层的方法。</p>
<p>这种业务层和持久层的依赖方法，在使用Spring之后，就由Spring来维护了。<br>简单来说，就是坐等框架来把持久层对象传入业务层，而不用我们自己去获取。</p>
<h2 id="7-Bean的依赖注入方式"><a href="#7-Bean的依赖注入方式" class="headerlink" title="7. Bean的依赖注入方式"></a>7. Bean的依赖注入方式</h2><p>把UserDao注入到UserService内部：</p>
<ul>
<li>构造方法</li>
<li>set方法</li>
</ul>
<p>（1）set方法注入<br>除了基本的set方法，还可以使用P命名空间<br>P命名空间本质也是set方法注入，但要更方便一些，主要体现在配置文件上：<br>首先，需要引入P命名空间：<br><code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code><br>其次，需要修改注入方式：<br><code>&lt;bean id=&quot;userService&quot; class=&quot;com.xjy.service.impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot;/&gt;</code></p>
<p>（2）构造方法注入</p>
<h2 id="8-Bean的依赖注入的数据类型"><a href="#8-Bean的依赖注入的数据类型" class="headerlink" title="8. Bean的依赖注入的数据类型"></a>8. Bean的依赖注入的数据类型</h2><p>上面的操作都是注入的引用Bean，除了对象的引用可以注入，普通数据类型、集合等都可以在容器中进行注入</p>
<p>注入数据的三种类型：</p>
<ul>
<li>普通数据类型</li>
<li>引用数据类型</li>
<li>集合数据类型</li>
</ul>
<h2 id="9-引入其他配置文件（分模块开发）"><a href="#9-引入其他配置文件（分模块开发）" class="headerlink" title="9. 引入其他配置文件（分模块开发）"></a>9. 引入其他配置文件（分模块开发）</h2><p>实际开发中，Spring的配置内容非常多，导致Spring配置很繁杂而且体积庞大， 所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载<br><code>&lt;import resource=&quot;applicationContext-xxx.xml&quot;/&gt;</code></p>
<h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h2><p><strong>Spring的重点配置</strong></p>
<ul>
<li>&lt;bean&gt;标签:  <ul>
<li>id属性：在容器Bean实例的唯一标识，不允许重复</li>
<li>class属性：要实例化的Bean的全限定名</li>
<li>scope属性：Bean的作用范围，常用Singleton（默认值）和prototype</li>
<li>&lt;property&gt; 标签：属性注入<ul>
<li>name属性：属性名称</li>
<li>value属性：注入的普通属性值</li>
<li>ref属性：注入的对象引用值</li>
<li>&lt;list&gt;标签</li>
<li>&lt;map&gt;标签</li>
<li>&lt;propertier&gt;标签</li>
</ul>
</li>
<li>&lt;constructor-arg&gt;标签</li>
</ul>
</li>
<li>&lt;import&gt;标签：导入其他的Spring的分文件</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/22/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/%E6%96%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴雨">
      <meta itemprop="description" content="晴雨之中，唯得一小屋以安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="晴雨屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/22/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/%E6%96%AD%E8%A8%80/" class="post-title-link" itemprop="url">java中的断言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-22 22:40:55" itemprop="dateCreated datePublished" datetime="2023-05-22T22:40:55+08:00">2023-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-24 11:29:51" itemprop="dateModified" datetime="2023-05-24T11:29:51+08:00">2023-05-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在软件开发中，调试和测试是不可或缺的步骤。为了帮助开发人员在代码中捕获潜在的错误和异常，Java引入了断言（assertions）机制。断言是一种声明，用于在代码中插入检查点，以确保某个条件为真。本文将深入探讨Java中的断言机制，包括其语法、工作原理和最佳实践。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>在Java中，断言使用<code>assert</code>关键字来定义。其基本语法形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> condition;</span><br></pre></td></tr></table></figure>
<p>其中，<code>condition</code>是需要进行检查的条件表达式。如果<code>condition</code>为假，断言将失败并抛出<code>AssertionError</code>异常。</p>
<h2 id="启用和禁用"><a href="#启用和禁用" class="headerlink" title="启用和禁用"></a>启用和禁用</h2><p>默认情况下，Java虚拟机在执行代码时将忽略断言。为了启用断言，我们可以在启动Java程序时使用命令行选项<code>-ea</code>或<code>-enableassertions</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -ea MyProgram</span><br></pre></td></tr></table></figure>
<p>这将启用<code>MyProgram</code>中的所有断言。如果只想为特定的类或包启用断言，可以使用<code>-ea:</code>或<code>-da:</code>选项。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -ea:com.example MyProgram</span><br></pre></td></tr></table></figure>
<p>这将仅启用<code>com.example</code>包中的断言。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>当启用断言时，Java虚拟机将在执行代码中的断言语句时进行检查。如果断言失败（即条件为假），则会抛出<code>AssertionError</code>异常。这个异常可以被捕获和处理，或者在没有处理的情况下导致程序终止。</p>
<h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><ul>
<li>断言主要用于调试和开发阶段，不应在生产环境中过度使用。</li>
<li>断言应该用于检查不应该发生的情况，而不是用于处理可能发生的错误。</li>
<li>断言的条件应该是纯粹的布尔表达式，避免在断言中执行复杂的操作。</li>
<li>断言不应该改变程序的状态或产生副作用。</li>
<li>断言的信息应该清晰明了，方便识别断言失败的原因。</li>
</ul>
<h2 id="与异常处理的区别"><a href="#与异常处理的区别" class="headerlink" title="与异常处理的区别"></a>与异常处理的区别</h2><p>断言与异常处理有所不同。断言是用于调试目的，用于捕获程序中的逻辑错误和不一致性。异常处理则用于处理运行时异常和错误条件。断言应该关注于程序的正确性和一致性，而异常处理则关注于程序的可靠性和健壮性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>断言是Java中一个有用的调试工具，可以帮助开发人员捕获潜在的错误和异常。通过合理使用断言，开发人员可以更早地发现和解决问题，提高代码的质量和可靠性。然而，断言应该谨慎使用，并在生产环境中进行适当的禁用，以避免不必要的性能开销。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/11/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="晴雨">
      <meta itemprop="description" content="晴雨之中，唯得一小屋以安。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="晴雨屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/11/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">设计模式总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-05-11 22:44:19 / 修改时间：23:24:19" itemprop="dateCreated datePublished" datetime="2023-05-11T22:44:19+08:00">2023-05-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前两天终于做完软构lab3了，接下来对java中的一些设计模式做一个简单的总结。<br>首先，同样推荐一个b站up主@林斯基JI，它的设计模式讲的挺好的，距离生动形象。</p>
<ol>
<li><p>工厂模式（Factory Pattern）： 工厂模式用于创建对象，将对象的创建逻辑与客户端代码分离。它通过一个工厂类来创建对象，客户端只需调用工厂类的方法即可获取所需的对象。工厂模式可以根据条件返回不同的对象实例，提供了灵活性和可扩展性。</p>
</li>
<li><p>观察者模式（Observer Pattern）： 观察者模式定义了对象之间的一对多依赖关系，当一个对象的状态发生变化时，其依赖的对象将自动得到通知并更新。在Java中，观察者模式可以使用<code>java.util.Observer</code>接口和<code>java.util.Observable</code>类实现。</p>
</li>
<li><p>装饰器模式（Decorator Pattern）： 装饰器模式允许动态地向对象添加额外的功能，而不需要修改其原始类。它通过将对象包装在装饰器类中，逐层叠加功能来实现。在Java中，可以使用继承和接口来实现装饰器模式。</p>
</li>
<li><p>策略模式（Strategy Pattern）： 策略模式定义了一组算法，将其封装成独立的策略类，并使它们可以互相替换。客户端可以根据需求选择不同的策略，而不需要了解具体的算法实现细节。在Java中，策略模式可以通过接口和多态性来实现。</p>
</li>
<li><p>适配器模式（Adapter Pattern）： 适配器模式用于将一个类的接口转换成客户端所期望的另一个接口。它使得原本不兼容的类可以一起工作。适配器模式可以通过继承或组合来实现适配器类。</p>
</li>
<li><p>模板方法模式（Template Method Pattern）： 模板方法模式定义了一个算法的骨架，将某些步骤的具体实现延迟到子类中。它提供了一个模板方法来定义算法的框架，而具体的步骤实现由子类决定。在Java中，可以使用抽象类和钩子方法来实现模板方法模式。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">晴雨</p>
  <div class="site-description" itemprop="description">晴雨之中，唯得一小屋以安。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">晴雨</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
